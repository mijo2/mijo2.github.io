I was lucky enough to pass the first evaluation of GSoC'20. I would like to thank my mentors for their constant support and valuable feedback. 

Aside the first evaluations, this week, the main work done was combining the solvers introduced previously in this project and finally making a version of
`dsolve_system`, which will be able to take a system of ODEs as an input and solve it appropriately using solvers added. 

# PR [#19653](https://github.com/sympy/sympy/pull/19653 "#19653")

Work done in this PR:
1. Combined the previously added solvers and combined it into a public function `linodesolve`.
2. Added `linodesolve_type` function, that can determine important information about the linear first order system of ODEs, given the coefficient matrix, the independent variable and the non-homogeneous term(if any).
3. Upgraded the `canonical_odes` function and added support for implicit system of ODEs.

This PR combined _linear_neq_order1_type1-4 solvers into `linodesolve`. A function that takes coefficient matrix, independent variable and non-homogeneous term(if any), and matches the appropriate solution to solve for the type of system passed. 

Lets define a test system to test our `linodesolve` function on:
```
In [2]: f, g = symbols('f g', cls=Function) 
   ...: eqs = [ 
   ...: Eq(f(x).diff(x), f(x) + y*g(x)),  
   ...: Eq(g(x).diff(x), f(x)*y - g(x))] 
   ...: funcs = [f(x), g(x)]
```
As you can see, the above system has the coefficient matrix defined below:
```
In [3]: M = Matrix([[1, y], [y, -1]])
```

Since, we know that the system that we have is linear, order 1, constant coefficient and non-homogeneous, the type of the system is "type1" and we can pass the appropriate arguments to get the solution for the system of ODEs:
```
In [4]: sol_vector = linodesolve(M, x, type="type1") 
In [6]: sol_vector                                                                                                                                                                                          
Out[6]: 
⎡              ________              ________                                        ⎤
⎢             ╱  2                  ╱  2                 ________            ________⎥
⎢        -x⋅╲╱  y  + 1          x⋅╲╱  y  + 1            ╱  2                ╱  2     ⎥
⎢  C₁⋅y⋅ℯ                 C₂⋅y⋅ℯ                   -x⋅╲╱  y  + 1        x⋅╲╱  y  + 1 ⎥
⎢- ──────────────────── + ───────────────────, C₁⋅ℯ               + C₂⋅ℯ             ⎥
⎢       ________               ________                                              ⎥
⎢      ╱  2                   ╱  2                                                   ⎥
⎣    ╲╱  y  + 1  + 1        ╲╱  y  + 1  - 1                                          ⎦

```
We can test the solution for the above system. The correctness of the solutions of the four types introduced is nothing to be worried since it is well tested in the file `sympy/solvers/ode/tests/test_systems.py`. But for the sake of testing this solution, the below is a method to test the correctness using `checksysodesol`
```
In [7]: sol = [Eq(func, s) for func, s in zip(funcs, sol_vector)]                                                                                                                                           

In [8]: checksysodesol(eqs, sol)                                                                                                                                                                            
Out[8]: (True, [0, 0])
```
`(True, [0, 0])` means the solution for the system is correct.

`linodesolve` is designed to handle a multiple number of cases. If the user doesn't pass the type of the system that is to be solved, then with the help of the default value of the `type` keyword argument, the function will be able to determine the type of the system internally.
```
In [10]: sol_vector_without_type = linodesolve(M, x)                                                                                                                                                        
In [11]: sol_vector_with_type = linodesolve(M, x, type="type1")
In [13]: sol_vector_with_type == sol_vector_without_type                                                                                                                                                    
Out[13]: True
```
It is encouraged to pass the type of the system if the end-user knows the type of the system beforehand. 

Since, these types are defined internally, we created a function named `linodesolve_type` that takes the coefficient matrix, the independent variable and the non-homogeneous term(if any) and returns the system information. In this information, the main thing is the type of the system, along with that it also returns the commutative antiderivative, if required to solve the system. of ODEs.

```
In [19]: f, g, h, k = symbols('f g h k', cls=Function) 
    ...: eqs = [ 
    ...: Eq(f(x).diff(x), x*f(x) + x*y*g(x)),  
    ...: Eq(g(x).diff(x), f(x)*y*x - x*g(x))] 
    ...: funcs = [f(x), g(x)]                                                                                                                                                                               

In [20]: M = Matrix([[x, x*y], [x*y, -1*x]])                                                                                                                                                                

In [21]: system_info = linodesolve_type(M, x)                                                                                                                                                               

In [22]: system_info                                                                                                                                                                                        
Out[22]: 
{'type': 'type3',
 'antiderivative': Matrix([
 [  x**2/2, x**2*y/2],
 [x**2*y/2,  -x**2/2]])}

```

If the system is of Type 2 or Type 1, then the value for the key `antiderivative` is None.
```
In [25]: system_info = linodesolve_type(M/x, x)                                                                                                                                                             

In [26]: system_info                                                                                                                                                                                        
Out[26]: {'type': 'type1', 'antiderivative': None}
```
If a non-homogenous term is not passed(as seen above), or a zero vector is passed,then the system is assumed to be homogeneous. But, if a non-zero non-homogeneous term is passed, then the type of the system maybe `type2` or `type4` depending on the fact that if the coefficient matrix is constant or not.
```
In [27]: linodesolve_type(M, x, b=None)['type']                                                                                                                                                             
Out[27]: 'type3'

In [28]: linodesolve_type(M, x, b=zeros(2, 1))['type']                                                                                                                                                      
Out[28]: 'type3'

In [29]: linodesolve_type(M, x, b=ones(2, 1))['type']                                                                                                                                                       
Out[29]: 'type4'

In [30]: linodesolve_type(M/x, x, b=ones(2, 1))['type']                                                                                                                                                     
Out[30]: 'type2'

```
Now, `linodesolve` cannot solve all the linear first order system of ODEs. It can solve all constant coefficient systems but it can only solve a subset of non-constant coefficient system of ODEs, namely, the systems whose coefficient matrix have a commutative antiderivative. If there is no commutative antiderivative for the coefficient matrix, then a `NotImplementedError` is raised by `linodesolve_type`(even by `linodesolve` if the system is non-constant, the antiderivative isn't passed and the antiderivative isnt commutative with its coefficient matrix).

```
In [31]: M = Matrix([[x, x*y], [y, -1]])

In [32]: linodesolve_type(M, x)                                                                                                                                                                             
---------------------------------------------------------------------------
NotImplementedError                       Traceback (most recent call last)
...
NotImplementedError: 
The system does not have a commutative antiderivative, it cannot be
solved by linodesolve.
```

There are system of ODEs which are implicit. Meaning, they can be solved for and divided into simpler systems and these systems may have a direct solution. We can get these solution systems from an implicit system using `canonical_odes` function. 
